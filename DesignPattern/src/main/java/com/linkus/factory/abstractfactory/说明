如果扩展一个产品等级，例如新增一个手机，也就是说新增一个品牌来生产手机，新增一个产品等级不用修改原来的代码，符合OCP原则，这是非常舒服的；
优点：一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象（将一个系列的产品统一一起创建）；

缺点：

产品族扩展非常困难，要增加一个系列的某一产品，既要修改工厂抽象类里加代码，又修改具体的实现类里面加代码；
增加了系统的抽象性和理解难度

一系列相关产品对象（属于同一产品族）一起创建时需要大量的重复代码；
提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现；
抽象工厂模式符合依赖抽象原则

创建对象实例时，不要直接 new一个对象， 而是把创建对象的动作放在一个工厂的方法中；
不要让类继承具体类，而是继承抽象类或者是实现接口；
不要覆盖基类中已经实现的方法；

模式的扩展
抽象工厂模式的扩展有一定的“开闭原则”倾斜性：
当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。

另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。